#include <iostream>
#include <fstream>

#include <boost/program_options.hpp>

#include "mp/following_detection.hpp"
#include "mp/following_graph.hpp"

#include "../common/util.hpp"
#include "../common/follower_file.hpp"

using namespace mp;
using namespace std;

void parse_options(int argc, char *argv[]);
void validate_options();

// Path to input feature file.
string in_file;

// The timestamp for graph generation.
bool absolute_timestamp = false;
i64  at_timestamp = 0;

// Path to output file and its type.
string out_file;
string out_type;

int main(int argc, char *argv[]) {
    setlocale(LC_ALL, "C");
    parse_options(argc, argv);
    validate_options();

    // Load follower data from file
    following_data followers;
    feature_parameters params;
    {
        fstream in_stream;
        try {
            try_open(in_stream, in_file, ios_base::in);
        } catch (const std::exception &e) {
            cerr << "failed to open input file \""
                 << in_file << "\": "
                 << e.what() << endl;
            exit(1);
        }

        cereal::JSONInputArchive ar(in_stream);
        load_follower_file(ar, followers, params);
    }

    cout << "Using follower data:\n"
         << "  Source:      " << in_file << "\n"
         << "  Data source: " << params.data_source << "\n"
         << "  Algorithm:   " << params.algorithm << "\n"
         << "  Window size: " << params.window_size << " seconds\n"
         << "  Time lag:    " << params.time_lag << " seconds\n"
         << "  Devices:     " << followers.devices.size() << "\n"
         << "  Begin:       " << followers.begin_timestamp << "\n"
         << "  End:         " << followers.end_timestamp << "\n"
         << "  Duration:    " << followers.duration << " seconds\n";

    i64 abs_ts = absolute_timestamp ? at_timestamp
                                    : followers.begin_timestamp + at_timestamp;
    i64 rel_ts = abs_ts - followers.begin_timestamp;

    cout << "Computation parameters:\n"
         << "  Output:           " << out_file << "\n"
         << "  Timestamp (abs.): " << abs_ts << "\n"
         << "  Timestamp (rel.): " << rel_ts << "\n"
         << flush;

    if (abs_ts < followers.begin_timestamp || abs_ts > followers.end_timestamp) {
        cerr << "Timestamp " << abs_ts << " is out of range. Exiting." << endl;
        exit(1);
    }

    following_graph graph = following_graph_at(followers, abs_ts);

    // Save graph to file
    {
        fstream out_stream;
        try {
            try_open(out_stream, out_file, ios_base::out | ios_base::trunc);
        } catch (const std::exception &e) {
            cerr << "failed to open output file \""
                 << out_file << "\": "
                 << e.what() << endl;
            exit(1);
        }

        if (out_type == "json") {
            cereal::JSONOutputArchive ar(out_stream);
            ar(cereal::make_nvp("params", params));
            ar(cereal::make_nvp("timestamp", abs_ts));
            ar(cereal::make_nvp("graph", graph));
        } else if (out_type == "graphml") {
            to_graphml(graph, out_stream);
        } else {
            throw std::logic_error("unsupported output type: " + out_type);
        }
    }

    return 0;
}

void parse_options(int argc, char *argv[])
{
    namespace po = boost::program_options;

    po::options_description opts("Options");
    opts.add_options()
            ("help,h",
             "Print this help message")
            ("input",
             po::value<string>(&in_file)->value_name("PATH")->required(),
             "The path to a file generated by the detect-followers program.")
            ("at",
              po::value<i64>(&at_timestamp)->value_name("TIMESTAMP")->required(),
             "Use the follower data at TIMESTAMP to generate the follower graph. "
             "By default, the timestamp is interpreted as relative from the beginning "
             "of the follower data (i.e. 0 -> first second).")
            ("absolute",
             po::bool_switch(&absolute_timestamp)->default_value(false),
             "Interpret the timestamp given for --at as absolute instead of relative.")
            ("output",
             po::value<string>(&out_file)->value_name("PATH")->required(),
             "The output path. The generated graph will be written to this file.")
            ("output-type",
             po::value<string>(&out_type)->value_name("TYPE")->required(),
             "The output format.\n"
             "Supported formats are:\n"
             "  json:    \tWrites a human-readable JSON file that contains the graph and some meta information\n"
             "  graphml: \tOutput a GraphML document. GraphML files can be read by many graph-visualization tools.")
            ;

    po::variables_map vm;
    try {
        auto parser = po::command_line_parser(argc, argv);
        parser.options(opts);
        po::store(parser.run(), vm);

        if (vm.count("help")) {
            cerr << "Usage: " << argv[0] << " [options]" << "\n";
            cerr << "\n";
            cerr << "This program takes a file previously created by the detect-followers\n"
                 << "program and extracts a following graph at some user-defined timestamp.\n"
                 << "The graph will contain an edge between two vertices \"a\" and \"b\"\n"
                 << "if \"a\" is classified as following \"b\".\n"
                 << "Multiple output formats are supported.\n\n"
                 << flush;
            cerr << opts << flush;
            exit(1);
        }

        po::notify(vm);
    } catch (const po::error &e) {
        cerr << e.what() << endl;
        exit(1);
    }
}

void validate_options()
{
    auto contains = [](const vector<string> &v, const string &s) {
        return std::find(v.begin(), v.end(), s) != v.end();
    };

    static const vector<string> allowed_output_types{"json", "graphml"};

    bool ok = true;
    if (!contains(allowed_output_types, out_type)) {
        cerr << "output type is invalid (" << out_type << ")" << endl;
        ok = false;
    }

    if (!ok) {
        exit(1);
    }
}

